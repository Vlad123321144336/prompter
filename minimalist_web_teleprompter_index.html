<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Minimalist Web Teleprompter</title>
    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel Standalone for in-browser TSX transform (dev/demo). For production, prebuild with Vite/Rollup. -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root { --tele-bg:#000; --tele-fg:#fff; }
      html, body, #root { height: 100%; }
      body { margin:0; background:var(--tele-bg); color:var(--tele-fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji; }
      .tele-scrollbar-hide { scrollbar-width: none; }
      .tele-scrollbar-hide::-webkit-scrollbar { display: none; }
      .tele-relative { position: relative; }
      .tele-flex-1 { flex: 1 1 auto; }
      .tele-slider { -webkit-appearance:none; appearance:none; height:6px; background:linear-gradient(90deg, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.6) var(--_val,50%), rgba(255,255,255,0.2) var(--_val,50%)); border-radius:999px; outline:none; }
      .tele-slider:focus { outline:none; }
      .tele-slider::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%; background:white; box-shadow:0 2px 4px rgba(0,0,0,0.3); }
      .tele-slider::-moz-range-thumb { width:14px; height:14px; border-radius:50%; background:white; box-shadow:0 2px 4px rgba(0,0,0,0.3); border:none; }
      @keyframes subtle-pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.05);} }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-presets="typescript,react">
      /** @jsxRuntime classic */
      // ‚Äî‚Äî‚Äî‚Äî‚Äî Types ‚Äî‚Äî‚Äî‚Äî‚Äî
      // Using TS types inline; Babel Standalone strips them via the typescript preset.
      
      // TextViewportRef interface
      
      // ‚Äî‚Äî‚Äî‚Äî‚Äî Hook: useGamepad ‚Äî‚Äî‚Äî‚Äî‚Äî
      function useGamepad(options) {
        const {
          onPlayPause,
          onSpeedDecrease,
          onSpeedIncrease,
          onJumpToStart,
          onJumpToEnd,
          onMirrorToggle,
          onFullscreenToggle,
          onFontSizeDecrease,
          onFontSizeIncrease,
          onManualScroll,
          onPauseFromManualScroll,
          isPlaying,
        } = options;

        const lastPressTimeRef = React.useRef(new Map());
        const rafRef = React.useRef(null);
        const lastTimeRef = React.useRef(performance.now());

        const DEADZONE = 0.15;
        const DEBOUNCE = 200; // ms
        const SMOOTH_FACTOR = 0.9;
        const smoothedSpeedRef = React.useRef(0);

        const debounce = (key) => {
          const now = performance.now();
          const last = lastPressTimeRef.current.get(key) ?? 0;
          if (now - last < DEBOUNCE) return false;
          lastPressTimeRef.current.set(key, now);
          return true;
        };

        const readButtons = (gp) => {
          const pressed = (idx) => gp.buttons[idx]?.pressed;
          const BTN = { A:0,B:1,X:2,Y:3,LB:4,RB:5,LT:6,RT:7,SELECT:8,START:9,L3:10,R3:11,DPAD_UP:12,DPAD_DOWN:13,DPAD_LEFT:14,DPAD_RIGHT:15 };

          if (pressed(BTN.A) && debounce("A")) onPlayPause();
          if (pressed(BTN.Y) && debounce("Y")) onMirrorToggle();
          if (pressed(BTN.X) && debounce("X")) onFullscreenToggle();
          if (pressed(BTN.LB) && debounce("LB")) onJumpToStart();
          if (pressed(BTN.RB) && debounce("RB")) onJumpToEnd();
          if (pressed(BTN.DPAD_LEFT) && debounce("DL")) onSpeedDecrease();
          if (pressed(BTN.DPAD_RIGHT) && debounce("DR")) onSpeedIncrease();
          if (pressed(BTN.DPAD_UP) && debounce("DU")) onFontSizeIncrease();
          if (pressed(BTN.DPAD_DOWN) && debounce("DD")) onFontSizeDecrease();

          const leftStickY = gp.axes?.[1] ?? 0;
          const mag = Math.abs(leftStickY);
          const dir = leftStickY < 0 ? -1 : 1;
          if (mag > DEADZONE) {
            const MIN = 5, MAX = 25;
            const target = (MIN + (MAX - MIN) * Math.pow((mag - DEADZONE) / (1 - DEADZONE), 2)) * dir;
            smoothedSpeedRef.current = smoothedSpeedRef.current * SMOOTH_FACTOR + target * (1 - SMOOTH_FACTOR);
            const now = performance.now();
            const dt = (now - lastTimeRef.current) / 1000;
            lastTimeRef.current = now;
            if (!isPlaying) {
              const scrollDelta = smoothedSpeedRef.current * 50 * dt;
              onManualScroll(scrollDelta);
            } else {
              onPauseFromManualScroll();
            }
          } else {
            smoothedSpeedRef.current = 0;
          }
        };

        const loop = () => {
          const pads = navigator.getGamepads?.() || [];
          for (const gp of pads) if (gp) readButtons(gp);
          rafRef.current = requestAnimationFrame(loop);
        };

        React.useEffect(() => {
          const onConnect = () => {
            if (rafRef.current == null) {
              lastTimeRef.current = performance.now();
              rafRef.current = requestAnimationFrame(loop);
            }
          };
          const onDisconnect = () => {
            if (navigator.getGamepads && Array.from(navigator.getGamepads()).every(g => !g)) {
              if (rafRef.current) cancelAnimationFrame(rafRef.current);
              rafRef.current = null;
            }
          };
          window.addEventListener("gamepadconnected", onConnect);
          window.addEventListener("gamepaddisconnected", onDisconnect);
          onConnect();
          return () => {
            window.removeEventListener("gamepadconnected", onConnect);
            window.removeEventListener("gamepaddisconnected", onDisconnect);
            if (rafRef.current) cancelAnimationFrame(rafRef.current);
          };
        }, [isPlaying]);
      }

      // ‚Äî‚Äî‚Äî‚Äî‚Äî UI atoms ‚Äî‚Äî‚Äî‚Äî‚Äî
      function IconButton(props) {
        return (
          <button title={props.title} onClick={props.onClick} disabled={props.inactive} style={{
            width:30, height:30, display:"inline-flex", alignItems:"center", justifyContent:"center",
            borderRadius:999, border:"none", cursor: props.inactive?"not-allowed":"pointer", color:"#fff",
            background: props.active?"rgba(255,255,255,0.3)":"rgba(255,255,255,0.1)"
          }}>{props.children}</button>
        );
      }

      function TrianglePointer({ size = 18, opacity = 0.5, pulse = false }) {
        return (
          <div style={{ position:"absolute", left:12, top:"50%", transform:"translateY(-50%)", zIndex:20,
                         opacity, filter:"drop-shadow(0 0 4px rgba(255,255,255,0.3))", pointerEvents:"none",
                         animation: pulse?"subtle-pulse 1.6s ease-in-out infinite":"none" }}>
            <svg width={size} height={size * 1.25} viewBox="0 0 16 20" aria-hidden>
              <path d="M2 2 L14 10 L2 18 Z" fill="#FFFFFF" />
            </svg>
          </div>
        );
      }

      function OrientationOverlay({ show }) {
        if (!show) return null;
        return (
          <div style={{ position:"fixed", inset:0, background:"#000", color:"#fff", zIndex:50, display:"grid", placeItems:"center", textAlign:"center", padding:24 }}>
            <div>
              <div style={{ fontSize:64, marginBottom:12, opacity:0.8 }} aria-hidden>‚Üª</div>
              <h1 style={{ margin:0, fontSize:24, marginBottom:8 }}>Rotate to landscape</h1>
              <p style={{ margin:0, opacity:0.7 }}>This app works in landscape mode only</p>
            </div>
          </div>
        );
      }

      function TopBar({ elapsedTime, remainingTime, progress, onNewScript }) {
        const fmt = (s) => { const mm = Math.floor(s/60); const ss = Math.floor(s%60); return `${mm}:${ss.toString().padStart(2,"0")}`; };
        return (
          <div style={{ height:56, background:"rgba(0,0,0,0.5)", backdropFilter:"blur(6px)", display:"flex", alignItems:"center", justifyContent:"space-between", padding:"0 12px", gap:12 }}>
            <button style={{ opacity:0.5, cursor:"not-allowed", borderRadius:999, padding:"8px 12px", background:"rgba(255,255,255,0.1)", border:"none", color:"#fff" }}>My Scripts</button>
            <div style={{ display:"flex", alignItems:"center", gap:12, minWidth:200 }}>
              <div style={{ color:"rgba(255,255,255,0.7)", fontVariantNumeric:"tabular-nums" }}>{fmt(elapsedTime)} / {fmt(remainingTime)}</div>
              <div style={{ width:96, height:6, background:"rgba(255,255,255,0.2)", borderRadius:999 }}>
                <div style={{ width: `${Math.max(0, Math.min(100, progress))}%`, height:"100%", background:"rgba(255,255,255,0.6)", borderRadius:999 }} />
              </div>
            </div>
            <button onClick={onNewScript} style={{ borderRadius:999, padding:"8px 12px", background:"rgba(255,255,255,0.1)", border:"none", color:"#fff" }}>New Script</button>
          </div>
        );
      }

      const TextViewport = React.forwardRef(function TextViewport(props, ref) {
        const scrollContainerRef = React.useRef(null);
        const rafRef = React.useRef(null);
        const lastTimeRef = React.useRef(performance.now());
        const scrollAccumulatorRef = React.useRef(0);
        const linePx = React.useMemo(() => props.fontSizePx * 1.3, [props.fontSizePx]);

        const getScrollInfo = React.useCallback(() => {
          const el = scrollContainerRef.current;
          if (!el) return { scrollTop:0, scrollHeight:0, clientHeight:0 };
          return { scrollTop: el.scrollTop, scrollHeight: el.scrollHeight, clientHeight: el.clientHeight };
        }, []);

        const tick = React.useCallback(() => {
          const now = performance.now();
          const dt = (now - lastTimeRef.current) / 1000;
          lastTimeRef.current = now;
          const el = scrollContainerRef.current; if (!el) return;
          if (props.isPlaying) {
            const t = (props.speed - 1) / 49;
            const linesPerSec = 0.5 + 9.5 * t;
            const pxPerSec = linesPerSec * linePx;
            const scrollDelta = pxPerSec * dt;
            scrollAccumulatorRef.current += scrollDelta;
            const whole = Math.floor(scrollAccumulatorRef.current);
            if (whole !== 0) {
              el.scrollTop = Math.min(el.scrollTop + whole, el.scrollHeight - el.clientHeight);
              scrollAccumulatorRef.current -= whole;
            }
            props.onScrollChange(getScrollInfo());
          }
          rafRef.current = requestAnimationFrame(tick);
        }, [getScrollInfo, linePx, props]);

        React.useEffect(() => {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
          lastTimeRef.current = performance.now();
          rafRef.current = requestAnimationFrame(tick);
          return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); rafRef.current = null; };
        }, [props.isPlaying, props.speed, tick]);

        React.useEffect(() => {
          const el = scrollContainerRef.current; if (!el) return;
          const ro = new ResizeObserver((entries) => { for (const entry of entries) props.onContainerHeightChange(entry.contentRect.height); });
          ro.observe(el);
          return () => ro.disconnect();
        }, [props]);

        const manualScroll = React.useCallback((delta) => {
          const el = scrollContainerRef.current; if (!el) return;
          el.scrollTop = Math.max(0, Math.min(el.scrollTop + delta, el.scrollHeight - el.clientHeight));
          props.onScrollChange(getScrollInfo());
        }, [getScrollInfo, props]);

        React.useImperativeHandle(ref, () => ({
          scrollToStart() { const el = scrollContainerRef.current; if (el) el.scrollTop = 0; props.onScrollChange(getScrollInfo()); },
          scrollToEnd() { const el = scrollContainerRef.current; if (el) el.scrollTop = el.scrollHeight - el.clientHeight; props.onScrollChange(getScrollInfo()); },
          getScrollInfo,
          manualScroll,
          getScrollElement() { return scrollContainerRef.current; },
        }));

        const paragraphs = React.useMemo(() => props.text.split("\n").map((p, i) => <p key={i} style={{ margin:0, padding:0 }}>{p}</p>), [props.text]);

        return (
          <div className="tele-relative tele-flex-1">
            {props.showPointer && (<TrianglePointer size={props.pointerSize} opacity={props.pointerOpacity} pulse={props.pointerPulse} />)}
            <div ref={scrollContainerRef} className="tele-scrollbar-hide" style={{ position:"relative", width:"100%", height:"100%", overflowY:"scroll", overflowX:"hidden" }}>
              <div style={{ height:"70%" }} />
              <div style={{ fontSize: props.fontSizePx, lineHeight:"1.3em" }}>{paragraphs}</div>
              <div style={{ height:"26%" }} />
            </div>
          </div>
        );
      });

      function BottomBar(props) {
        return (
          <div style={{ height:64, background:"rgba(0,0,0,0.5)", backdropFilter:"blur(6px)", display:"flex", alignItems:"center", justifyContent:"space-between", padding:"0 12px", gap:8 }}>
            <div style={{ display:"flex", alignItems:"center", gap:8 }}>
              <IconButton title="Settings (inactive)" inactive><span style={{ fontSize:16 }}>‚öôÔ∏è</span></IconButton>
              <IconButton title="Go to start" onClick={props.onGoToStart}>‚Ü∞</IconButton>
              {props.isPlaying ? (
                <IconButton title="Pause" onClick={props.onPause} active>‚è∏</IconButton>
              ) : (
                <IconButton title="Play" onClick={props.onStart} active>‚ñ∂</IconButton>
              )}
              <IconButton title="Go to end" onClick={props.onGoToEnd}>‚Ü±</IconButton>
              <IconButton title="Mirror" onClick={props.onMirrorToggle} active={props.mirror}>‚Üî</IconButton>
              <IconButton title="Fullscreen" onClick={props.onFullscreenToggle}>‚õ∂</IconButton>
            </div>

            <div style={{ display:"flex", alignItems:"center", gap:12 }}>
              <div style={{ display:"flex", alignItems:"center", gap:6 }}>
                <span aria-hidden>üê¢</span>
                <input className="tele-slider" type="range" min={1} max={50} value={props.speed} onChange={(e)=>props.onSpeedChange(Number(e.target.value))} style={{ width:180 }} />
                <span aria-hidden>üêá</span>
                <span style={{ width:24, textAlign:"right", fontVariantNumeric:"tabular-nums" }}>{props.speed}</span>
              </div>
              <div style={{ display:"flex", alignItems:"center", gap:6 }}>
                <span aria-hidden style={{ textDecoration:"underline" }}>A</span>
                <input className="tele-slider" type="range" min={props.minFontSize} max={props.maxFontSize} value={props.fontSizePx} onChange={(e)=>props.onFontSizeChange(Number(e.target.value))} style={{ width:180 }} />
                <span>A</span>
                <span style={{ width:40, textAlign:"right", fontVariantNumeric:"tabular-nums" }}>{props.fontSizePx}</span>
              </div>
            </div>
          </div>
        );
      }

      function App() {
        const [isLandscape, setIsLandscape] = React.useState(true);
        const [isPlaying, setIsPlaying] = React.useState(false);
        const [speed, setSpeed] = React.useState(3);
        const [fontSizePx, setFontSizePx] = React.useState(72);
        const [mirror, setMirror] = React.useState(false);

        const [elapsedTime, setElapsedTime] = React.useState(0);
        const [remainingTime, setRemainingTime] = React.useState(0);
        const [progress, setProgress] = React.useState(0);
        const [containerHeight, setContainerHeight] = React.useState(0);

        const [scriptText, setScriptText] = React.useState(`Teleprompter Demo\n\nPaste your script with the New Script button (clipboard).\n\nUse gamepad: A=Play/Pause, LB/RB=Jump Start/End, Y=Mirror, X=Fullscreen.\nD-Pad ‚Üê/‚Üí speed, ‚Üë/‚Üì font size. Left stick for manual scroll when paused.`);

        const [showPointer, setShowPointer] = React.useState(true);
        const [pointerSize, setPointerSize] = React.useState(18);
        const [pointerOpacity, setPointerOpacity] = React.useState(0.5);
        const [pointerPulse, setPointerPulse] = React.useState(false);

        const textViewportRef = React.useRef(null);
        const startTimeRef = React.useRef(0);
        const pausedTimeRef = React.useRef(0);
        const lastPauseStartRef = React.useRef(null);

        React.useEffect(() => {
          const check = () => setIsLandscape(window.innerWidth > window.innerHeight);
          check();
          window.addEventListener("resize", check);
          window.addEventListener("orientationchange", check);
          return () => { window.removeEventListener("resize", check); window.removeEventListener("orientationchange", check); };
        }, []);

        React.useEffect(() => {
          let timer = null;
          if (isPlaying) {
            if (startTimeRef.current === 0) startTimeRef.current = Date.now();
            if (lastPauseStartRef.current != null) { pausedTimeRef.current += Date.now() - lastPauseStartRef.current; lastPauseStartRef.current = null; }
            timer = window.setInterval(() => {
              const now = Date.now();
              const e = (now - startTimeRef.current - pausedTimeRef.current) / 1000;
              setElapsedTime(Math.max(0, e));
            }, 100);
          } else {
            if (lastPauseStartRef.current == null && startTimeRef.current !== 0) lastPauseStartRef.current = Date.now();
            if (timer) window.clearInterval(timer);
          }
          return () => { if (timer) window.clearInterval(timer); };
        }, [isPlaying]);

        const handleScrollChange = React.useCallback((info) => {
          const { scrollTop, scrollHeight, clientHeight } = info;
          const maxScroll = Math.max(1, scrollHeight - clientHeight);
          setProgress((scrollTop / maxScroll) * 100);
          const remainingScroll = maxScroll - scrollTop;
          const t = (speed - 1) / 49;
          const curved = Math.pow(t, 1.2);
          const linesPerSec = 0.2 + 4.8 * curved;
          const pxPerSec = linesPerSec * (fontSizePx * 1.3);
          setRemainingTime(pxPerSec > 0 ? remainingScroll / pxPerSec : 0);
        }, [speed, fontSizePx]);

        const handleStart = () => setIsPlaying(true);
        const handlePause = () => setIsPlaying(false);
        const handleSpeedChange = (n) => setSpeed(Math.max(1, Math.min(50, Math.round(n))));
        const handleFontSizeChange = (n) => setFontSizePx(Math.max(24, Math.round(n)));
        const handleMirrorToggle = () => setMirror(m => !m);
        const handleGoToStart = () => textViewportRef.current?.scrollToStart();
        const handleGoToEnd = () => textViewportRef.current?.scrollToEnd();
        const handleFullscreenToggle = async () => {
          if (!document.fullscreenElement) {
            try { await document.documentElement.requestFullscreen(); } catch {}
          } else {
            try { await document.exitFullscreen(); } catch {}
          }
        };
        const handleManualScroll = (delta) => { textViewportRef.current?.manualScroll(delta); };
        const handlePauseFromManualScroll = () => setIsPlaying(false);
        const handleNewScript = async () => {
          try {
            const text = await navigator.clipboard.readText();
            if (text && text.trim()) {
              setScriptText(text);
              startTimeRef.current = 0; pausedTimeRef.current = 0; lastPauseStartRef.current = null;
              setElapsedTime(0); setRemainingTime(0); setProgress(0); setIsPlaying(false);
              textViewportRef.current?.scrollToStart();
            }
          } catch (e) { console.warn("Clipboard read failed", e); }
        };

        const maxFontSize = React.useMemo(() => (containerHeight > 0 ? Math.floor(containerHeight / 3) : 192), [containerHeight]);
        const minFontSize = 24;
        const clampedFontSize = Math.min(Math.max(fontSizePx, minFontSize), maxFontSize);

        useGamepad({
          onPlayPause: () => (isPlaying ? handlePause() : handleStart()),
          onSpeedDecrease: () => handleSpeedChange(speed - 1),
          onSpeedIncrease: () => handleSpeedChange(speed + 1),
          onJumpToStart: handleGoToStart,
          onJumpToEnd: handleGoToEnd,
          onMirrorToggle: handleMirrorToggle,
          onFullscreenToggle: handleFullscreenToggle,
          onFontSizeDecrease: () => handleFontSizeChange(clampedFontSize - 1),
          onFontSizeIncrease: () => handleFontSizeChange(clampedFontSize + 1),
          onManualScroll: handleManualScroll,
          onPauseFromManualScroll: handlePauseFromManualScroll,
          isPlaying,
          currentSpeed: speed,
        });

        return (
          <div style={{ width:"100%", height:"100%" }}>
            <OrientationOverlay show={!isLandscape} />
            <div style={{ width:"clamp(640px, 100dvw, 1000px)", height:"clamp(360px, 100dvh, 560px)", margin:"0 auto", display:"flex", flexDirection:"column", gap:8, transform: mirror?"scaleX(-1)":"none", transition:"transform 0.3s ease" }}>
              <TopBar elapsedTime={elapsedTime} remainingTime={remainingTime} progress={progress} onNewScript={handleNewScript} />
              <div style={{ flex:1, display:"flex", minHeight:0 }}>
                <TextViewport ref={textViewportRef} text={scriptText} isPlaying={isPlaying} speed={speed} fontSizePx={clampedFontSize} mirror={mirror} onScrollChange={handleScrollChange} onContainerHeightChange={setContainerHeight} showPointer={showPointer} pointerSize={pointerSize} pointerOpacity={pointerOpacity} pointerPulse={pointerPulse} />
              </div>
              <BottomBar isPlaying={isPlaying} speed={speed} fontSizePx={clampedFontSize} mirror={mirror} minFontSize={minFontSize} maxFontSize={maxFontSize}
                onStart={handleStart} onPause={handlePause}
                onSpeedChange={(n)=>{ setSpeed(n); const pct = ((n-1)/49)*100; document.querySelectorAll(".tele-slider[type=range]").forEach(el=>el.style.setProperty("--_val", pct+"%")); }}
                onFontSizeChange={setFontSizePx}
                onGoToStart={handleGoToStart} onGoToEnd={handleGoToEnd} onMirrorToggle={handleMirrorToggle} onFullscreenToggle={handleFullscreenToggle}
              />
            </div>
            <div style={{ position:"fixed", bottom:8, left:8, opacity:0.2, fontSize:12 }}>
              <label style={{ marginRight:8 }}><input type="checkbox" checked={showPointer} onChange={(e)=>setShowPointer(e.target.checked)} /> pointer</label>
              <label style={{ marginRight:8 }}>size <input type="number" value={pointerSize} onChange={(e)=>setPointerSize(Number(e.target.value))} style={{ width:56 }} /></label>
              <label style={{ marginRight:8 }}>opacity <input type="number" step={0.1} value={pointerOpacity} onChange={(e)=>setPointerOpacity(Number(e.target.value))} style={{ width:56 }} /></label>
              <label><input type="checkbox" checked={pointerPulse} onChange={(e)=>setPointerPulse(e.target.checked)} /> pulse</label>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
